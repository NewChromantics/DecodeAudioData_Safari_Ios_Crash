<!DOCTYPE html>
<html>

<head>
<style>
body
{
	font-size:	50pt;
}
</style>
	<button onclick="Start()" style="width:200px;height:200px">Start test</button>
	<div id="SampleMeta">SampleMeta</div>
	<div id="DebugBox">Debug:</div>
	<script>
	let Pop = {};
	Pop.CreatePromise = function()
	{
		let Callbacks = {};
		let PromiseHandler = function(Resolve,Reject)
		{
			Callbacks.Resolve = Resolve;
			Callbacks.Reject = Reject;
		}
		let Prom = new Promise(PromiseHandler);
		Prom.Resolve = Callbacks.Resolve;
		Prom.Reject = Callbacks.Reject;
		return Prom;
	}
		
	Pop.Yield = function(Milliseconds)
	{
		const Promise = Pop.CreatePromise();
		setTimeout( Promise.Resolve, Milliseconds );
		return Promise;
	}
	
	let gAudioContext = null;
	const AudioContextPromise = Pop.CreatePromise();
	let SoundUrls = ['AudioAssets/Blue/Cluster5_BluePlaneOrgan.mp3'];
	//let SoundUrls = ['AudioAssets/Silence500.mp3'];
	const CropSoundSize = 1024*40;//null;
	let SoundDatas = {};	//	[url]
	let Sounds = [];
	let SoundBuffers = [];	
	
	function SetDivText(Name,Contents)
	{
		const DebugBox = document.querySelector(`#${Name}`);
		DebugBox.innerHTML = Contents;
	}
	
	function PushDebug()
	{
		const DebugBox = document.querySelector('#DebugBox');
		const DebugText = Array.from(arguments).join(', ');
		//	place new text at the top
		DebugBox.innerHTML = DebugText +'<br/>' + DebugBox.innerHTML;
	}
	Pop.Debug = function()
	{
		console.log(...arguments);
		PushDebug(...arguments)
	}
	Pop.Warning = function()
	{
		console.warn(...arguments);
		PushDebug(...arguments)
	}
		

	async function DecodeAudioSample(AudioDataOrig)
	{
		const Context = await AudioContextPromise;
		const SliceSize = CropSoundSize ? CropSoundSize : AudioDataOrig.byteLength;
		//	decodeAudioData frees the underlying buffer to reduce memory usage,
		//	so we always need to slice/copy the buffer
		const AudioData = AudioDataOrig.slice(0,SliceSize);
		SetDivText('SampleMeta',`Compressed audio data x${AudioData.byteLength} bytes`);
		const DecodePromise = Pop.CreatePromise();
		//	gr: "newer" api returns a promise, but safari ios errors with 1 arg, so is using old syntax
		//	https://developer.mozilla.org/en-US/docs/Web/API/BaseAudioContext/decodeAudioData
		Context.decodeAudioData(AudioData,DecodePromise.Resolve,DecodePromise.Reject);
		const SoundBuffer = await DecodePromise;
		SoundBuffers.push(SoundBuffer);
		Pop.Debug(`Now have ${SoundBuffers.length} sound buffers`);
		return SoundBuffer;
	}

	function GetAudioContext()
	{
		if ( !gAudioContext )
		{
			const TAudioContext = window.AudioContext || window.webkitAudioContext;
			gAudioContext = new TAudioContext();
			AudioContextPromise.Resolve(gAudioContext);
		}
		return gAudioContext;
	}
	
	class Sound_t
	{
		constructor(AudioData)
		{
			this.AudioData = AudioData;
			this.Play().catch(Pop.Debug);
		}
		
		async Play()
		{
			const SampleBuffer = await DecodeAudioSample(this.AudioData);
			//	gr: test, dont store on self
			//	gr: if you dont store, crash ~80 (general oom?)
			this.SampleBuffer = SampleBuffer;
			
		}
	}
	
	async function LoadSoundData(Url)
	{
		if ( !SoundDatas.hasOwnProperty(Url) )
		{
			const Response = await fetch(Url);
			const Contents = await Response.arrayBuffer();
			Pop.Debug(`Loaded ${Url} x${Contents.byteLength} bytes`);
			SoundDatas[Url] = Contents;
		}
		return SoundDatas[Url];
	}
	
	async function LoadSound(Url)
	{
		const Data = await LoadSoundData(Url);
		const Sound = new Sound_t(Data);
		Sounds.push(Sound);
	}
	
	function FreeSamples()
	{
		for ( let i=0;	i<SoundBuffers.length;	i++ )
		{
			if ( !SoundBuffers[i] )
				continue;
			Pop.Debug(`Free/nulling sample buffer ${i}`);
			SoundBuffers[i] = null;
		}
	}
	
	let Pause = 150;
	async function TestRun()
	{
		Pop.Debug(`Waiting for audio context`);
		await AudioContextPromise;
		Pop.Debug(`Got audio context`);

		for ( let i=0;	i<300;	i++ )
		{
			await LoadSound(SoundUrls[0]);
			await Pop.Yield(Pause);
			
			FreeSamples();
		}	
	}
	
	function Start()
	{
		TestRun().catch(Pop.Debug);
		GetAudioContext();
	}
	
	
	</script>
</body>

</html>
