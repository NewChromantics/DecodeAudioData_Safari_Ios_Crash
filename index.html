<!DOCTYPE html>
<html>

<head>
<style>
body
{
	font-size:	50pt;
}
</style>
	<button onclick="Start()" style="width:200px;height:200px">Start test</button>
	<div id="SampleMeta">SampleMeta</div>
	<div id="DebugBox">Debug:</div>
	<script src='PopEngineCommon/PopWebApi.js'></script>	
	<script src='PopEngineCommon/PopApi.js'></script>	
	<script>
	
	let gAudioContext = null;
	const AudioContextPromise = Pop.CreatePromise();
	let SoundUrls = ['AudioAssets/Blue/Cluster5_BluePlaneOrgan.mp3'];
	//let SoundUrls = ['AudioAssets/Silence500.mp3'];
	const CropSoundSize = 1024*40;//null;
	let SoundDatas = {};	//	[url]
	let Sounds = [];
	let SoundBuffers = [];	
	
	function SetDivText(Name,Contents)
	{
		const DebugBox = document.querySelector(`#${Name}`);
		DebugBox.innerHTML = Contents;
	}
	
	function PushDebug()
	{
		const DebugBox = document.querySelector('#DebugBox');
		const DebugText = Array.from(arguments).join(', ');
		//	place new text at the top
		DebugBox.innerHTML = DebugText +'<br/>' + DebugBox.innerHTML;
	}
	Pop.Debug = function()
	{
		console.log(...arguments);
		PushDebug(...arguments)
	}
	Pop.Warning = function()
	{
		console.warn(...arguments);
		PushDebug(...arguments)
	}
		

	async function DecodeAudioSample(AudioDataOrig)
	{
		const Context = await AudioContextPromise;
		const SliceSize = CropSoundSize ? CropSoundSize : AudioDataOrig.byteLength;
		const AudioData = AudioDataOrig.slice(0,SliceSize);
		SetDivText('SampleMeta',`Compressed audio data x${AudioData.byteLength} bytes`);
		const DecodePromise = Pop.CreatePromise();
		Context.decodeAudioData(AudioData,DecodePromise.Resolve,DecodePromise.Reject);
		const SoundBuffer = await DecodePromise;
		SoundBuffers.push(SoundBuffer);
		Pop.Debug(`Now have ${SoundBuffers.length} sound buffers`);
		return SoundBuffer;
	}

	function GetAudioContext()
	{
		if ( !gAudioContext )
		{
			const TAudioContext = window.AudioContext || window.webkitAudioContext;
			gAudioContext = new TAudioContext();
			AudioContextPromise.Resolve(gAudioContext);
		}
		return gAudioContext;
	}
	
	class Sound_t
	{
		constructor(AudioData)
		{
			this.AudioData = AudioData;
			this.Play().catch(Pop.Debug);
		}
		
		async Play()
		{
			this.SampleBuffer = await DecodeAudioSample(this.AudioData);
			
		}
	}
	
	async function LoadSoundData(Url)
	{
		if ( !SoundDatas.hasOwnProperty(Url) )
		{
			const Response = await fetch(Url);
			const Contents = await Response.arrayBuffer();
			Pop.Debug(`Loaded ${Url} x${Contents.byteLength} bytes`);
			SoundDatas[Url] = Contents;
		}
		return SoundDatas[Url];
	}
	
	async function LoadSound(Url)
	{
		const Data = await LoadSoundData(Url);
		const Sound = new Sound_t(Data);
		Sounds.push(Sound);
	}
	
	function FreeSamples()
	{
		for ( let i=0;	i<SoundBuffers.length;	i++ )
		{
			if ( !SoundBuffers[i] )
				continue;
			Pop.Debug(`Free/nulling sample buffer ${i}`);
			SoundBuffers[i] = null;
		}
	}
	
	let Pause = 150;
	async function TestRun()
	{
		Pop.Debug(`Waiting for audio context`);
		await AudioContextPromise;
		Pop.Debug(`Got audio context`);

		for ( let i=0;	i<100;	i++ )
		{
			await LoadSound(SoundUrls[0]);
			await Pop.Yield(Pause);
			
			FreeSamples();
		}	
	}
	
	function Start()
	{
		TestRun().catch(Pop.Debug);
		GetAudioContext();
	}
	
	
	</script>
</body>

</html>
